// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/moominzie/user-record/ent/branch"
	"github.com/moominzie/user-record/ent/building"
	"github.com/moominzie/user-record/ent/faculty"
	"github.com/moominzie/user-record/ent/room"
	"github.com/moominzie/user-record/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBranch   = "Branch"
	TypeBuilding = "Building"
	TypeFaculty  = "Faculty"
	TypeRoom     = "Room"
	TypeUser     = "User"
)

// BranchMutation represents an operation that mutate the Branches
// nodes in the graph.
type BranchMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	brname                   *string
	clearedFields            map[string]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Branch, error)
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows to manage the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for $n.Name.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the id field of the mutation.
func withBranchID(id int) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BranchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBrname sets the brname field.
func (m *BranchMutation) SetBrname(s string) {
	m.brname = &s
}

// Brname returns the brname value in the mutation.
func (m *BranchMutation) Brname() (r string, exists bool) {
	v := m.brname
	if v == nil {
		return
	}
	return *v, true
}

// OldBrname returns the old brname value of the Branch.
// If the Branch object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BranchMutation) OldBrname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrname: %w", err)
	}
	return oldValue.Brname, nil
}

// ResetBrname reset all changes of the "brname" field.
func (m *BranchMutation) ResetBrname() {
	m.brname = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BranchMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BranchMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BranchMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BranchMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BranchMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.brname != nil {
		fields = append(fields, branch.FieldBrname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldBrname:
		return m.Brname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldBrname:
		return m.OldBrname(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldBrname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrname(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BranchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldBrname:
		m.ResetBrname()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BuildingMutation represents an operation that mutate the Buildings
// nodes in the graph.
type BuildingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	buname                   *string
	clearedFields            map[string]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Building, error)
}

var _ ent.Mutation = (*BuildingMutation)(nil)

// buildingOption allows to manage the mutation configuration using functional options.
type buildingOption func(*BuildingMutation)

// newBuildingMutation creates new mutation for $n.Name.
func newBuildingMutation(c config, op Op, opts ...buildingOption) *BuildingMutation {
	m := &BuildingMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildingID sets the id field of the mutation.
func withBuildingID(id int) buildingOption {
	return func(m *BuildingMutation) {
		var (
			err   error
			once  sync.Once
			value *Building
		)
		m.oldValue = func(ctx context.Context) (*Building, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Building.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilding sets the old Building of the mutation.
func withBuilding(node *Building) buildingOption {
	return func(m *BuildingMutation) {
		m.oldValue = func(context.Context) (*Building, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BuildingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBuname sets the buname field.
func (m *BuildingMutation) SetBuname(s string) {
	m.buname = &s
}

// Buname returns the buname value in the mutation.
func (m *BuildingMutation) Buname() (r string, exists bool) {
	v := m.buname
	if v == nil {
		return
	}
	return *v, true
}

// OldBuname returns the old buname value of the Building.
// If the Building object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildingMutation) OldBuname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuname: %w", err)
	}
	return oldValue.Buname, nil
}

// ResetBuname reset all changes of the "buname" field.
func (m *BuildingMutation) ResetBuname() {
	m.buname = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BuildingMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BuildingMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BuildingMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BuildingMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BuildingMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BuildingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Building).
func (m *BuildingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BuildingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.buname != nil {
		fields = append(fields, building.FieldBuname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BuildingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case building.FieldBuname:
		return m.Buname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BuildingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case building.FieldBuname:
		return m.OldBuname(ctx)
	}
	return nil, fmt.Errorf("unknown Building field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case building.FieldBuname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuname(v)
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BuildingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BuildingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Building numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BuildingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BuildingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Building nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BuildingMutation) ResetField(name string) error {
	switch name {
	case building.FieldBuname:
		m.ResetBuname()
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BuildingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BuildingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BuildingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BuildingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BuildingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BuildingMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BuildingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Building unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BuildingMutation) ResetEdge(name string) error {
	switch name {
	case building.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Building edge %s", name)
}

// FacultyMutation represents an operation that mutate the Faculties
// nodes in the graph.
type FacultyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	fname                    *string
	clearedFields            map[string]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Faculty, error)
}

var _ ent.Mutation = (*FacultyMutation)(nil)

// facultyOption allows to manage the mutation configuration using functional options.
type facultyOption func(*FacultyMutation)

// newFacultyMutation creates new mutation for $n.Name.
func newFacultyMutation(c config, op Op, opts ...facultyOption) *FacultyMutation {
	m := &FacultyMutation{
		config:        c,
		op:            op,
		typ:           TypeFaculty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacultyID sets the id field of the mutation.
func withFacultyID(id int) facultyOption {
	return func(m *FacultyMutation) {
		var (
			err   error
			once  sync.Once
			value *Faculty
		)
		m.oldValue = func(ctx context.Context) (*Faculty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faculty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaculty sets the old Faculty of the mutation.
func withFaculty(node *Faculty) facultyOption {
	return func(m *FacultyMutation) {
		m.oldValue = func(context.Context) (*Faculty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFname sets the fname field.
func (m *FacultyMutation) SetFname(s string) {
	m.fname = &s
}

// Fname returns the fname value in the mutation.
func (m *FacultyMutation) Fname() (r string, exists bool) {
	v := m.fname
	if v == nil {
		return
	}
	return *v, true
}

// OldFname returns the old fname value of the Faculty.
// If the Faculty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacultyMutation) OldFname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFname: %w", err)
	}
	return oldValue.Fname, nil
}

// ResetFname reset all changes of the "fname" field.
func (m *FacultyMutation) ResetFname() {
	m.fname = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *FacultyMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *FacultyMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *FacultyMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *FacultyMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *FacultyMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *FacultyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Faculty).
func (m *FacultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacultyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.fname != nil {
		fields = append(fields, faculty.FieldFname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faculty.FieldFname:
		return m.Fname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faculty.FieldFname:
		return m.OldFname(ctx)
	}
	return nil, fmt.Errorf("unknown Faculty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faculty.FieldFname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFname(v)
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacultyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacultyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacultyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacultyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Faculty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacultyMutation) ResetField(name string) error {
	switch name {
	case faculty.FieldFname:
		m.ResetFname()
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacultyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacultyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacultyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacultyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacultyMutation) ResetEdge(name string) error {
	switch name {
	case faculty.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Faculty edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	rname                    *string
	clearedFields            map[string]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRname sets the rname field.
func (m *RoomMutation) SetRname(s string) {
	m.rname = &s
}

// Rname returns the rname value in the mutation.
func (m *RoomMutation) Rname() (r string, exists bool) {
	v := m.rname
	if v == nil {
		return
	}
	return *v, true
}

// OldRname returns the old rname value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRname: %w", err)
	}
	return oldValue.Rname, nil
}

// ResetRname reset all changes of the "rname" field.
func (m *RoomMutation) ResetRname() {
	m.rname = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *RoomMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *RoomMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *RoomMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *RoomMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *RoomMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rname != nil {
		fields = append(fields, room.FieldRname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRname:
		return m.Rname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRname:
		return m.OldRname(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRname(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRname:
		m.ResetRname()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	personalID      *string
	personalName    *string
	clearedFields   map[string]struct{}
	faculty         *int
	clearedfaculty  bool
	branch          *int
	clearedbranch   bool
	building        *int
	clearedbuilding bool
	room            *int
	clearedroom     bool
	done            bool
	oldValue        func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPersonalID sets the personalID field.
func (m *UserMutation) SetPersonalID(s string) {
	m.personalID = &s
}

// PersonalID returns the personalID value in the mutation.
func (m *UserMutation) PersonalID() (r string, exists bool) {
	v := m.personalID
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalID returns the old personalID value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalID: %w", err)
	}
	return oldValue.PersonalID, nil
}

// ResetPersonalID reset all changes of the "personalID" field.
func (m *UserMutation) ResetPersonalID() {
	m.personalID = nil
}

// SetPersonalName sets the personalName field.
func (m *UserMutation) SetPersonalName(s string) {
	m.personalName = &s
}

// PersonalName returns the personalName value in the mutation.
func (m *UserMutation) PersonalName() (r string, exists bool) {
	v := m.personalName
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalName returns the old personalName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalName: %w", err)
	}
	return oldValue.PersonalName, nil
}

// ResetPersonalName reset all changes of the "personalName" field.
func (m *UserMutation) ResetPersonalName() {
	m.personalName = nil
}

// SetFacultyID sets the faculty edge to Faculty by id.
func (m *UserMutation) SetFacultyID(id int) {
	m.faculty = &id
}

// ClearFaculty clears the faculty edge to Faculty.
func (m *UserMutation) ClearFaculty() {
	m.clearedfaculty = true
}

// FacultyCleared returns if the edge faculty was cleared.
func (m *UserMutation) FacultyCleared() bool {
	return m.clearedfaculty
}

// FacultyID returns the faculty id in the mutation.
func (m *UserMutation) FacultyID() (id int, exists bool) {
	if m.faculty != nil {
		return *m.faculty, true
	}
	return
}

// FacultyIDs returns the faculty ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacultyID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FacultyIDs() (ids []int) {
	if id := m.faculty; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaculty reset all changes of the "faculty" edge.
func (m *UserMutation) ResetFaculty() {
	m.faculty = nil
	m.clearedfaculty = false
}

// SetBranchID sets the branch edge to Branch by id.
func (m *UserMutation) SetBranchID(id int) {
	m.branch = &id
}

// ClearBranch clears the branch edge to Branch.
func (m *UserMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared returns if the edge branch was cleared.
func (m *UserMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchID returns the branch id in the mutation.
func (m *UserMutation) BranchID() (id int, exists bool) {
	if m.branch != nil {
		return *m.branch, true
	}
	return
}

// BranchIDs returns the branch ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BranchIDs() (ids []int) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch reset all changes of the "branch" edge.
func (m *UserMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// SetBuildingID sets the building edge to Building by id.
func (m *UserMutation) SetBuildingID(id int) {
	m.building = &id
}

// ClearBuilding clears the building edge to Building.
func (m *UserMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared returns if the edge building was cleared.
func (m *UserMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the building id in the mutation.
func (m *UserMutation) BuildingID() (id int, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the building ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding reset all changes of the "building" edge.
func (m *UserMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// SetRoomID sets the room edge to Room by id.
func (m *UserMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to Room.
func (m *UserMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *UserMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *UserMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *UserMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.personalID != nil {
		fields = append(fields, user.FieldPersonalID)
	}
	if m.personalName != nil {
		fields = append(fields, user.FieldPersonalName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPersonalID:
		return m.PersonalID()
	case user.FieldPersonalName:
		return m.PersonalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldPersonalID:
		return m.OldPersonalID(ctx)
	case user.FieldPersonalName:
		return m.OldPersonalName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldPersonalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalID(v)
		return nil
	case user.FieldPersonalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldPersonalID:
		m.ResetPersonalID()
		return nil
	case user.FieldPersonalName:
		m.ResetPersonalName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.faculty != nil {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.branch != nil {
		edges = append(edges, user.EdgeBranch)
	}
	if m.building != nil {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.room != nil {
		edges = append(edges, user.EdgeRoom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFaculty:
		if id := m.faculty; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfaculty {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.clearedbranch {
		edges = append(edges, user.EdgeBranch)
	}
	if m.clearedbuilding {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.clearedroom {
		edges = append(edges, user.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeFaculty:
		return m.clearedfaculty
	case user.EdgeBranch:
		return m.clearedbranch
	case user.EdgeBuilding:
		return m.clearedbuilding
	case user.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ClearFaculty()
		return nil
	case user.EdgeBranch:
		m.ClearBranch()
		return nil
	case user.EdgeBuilding:
		m.ClearBuilding()
		return nil
	case user.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ResetFaculty()
		return nil
	case user.EdgeBranch:
		m.ResetBranch()
		return nil
	case user.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case user.EdgeRoom:
		m.ResetRoom()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
